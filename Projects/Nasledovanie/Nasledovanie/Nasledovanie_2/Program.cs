using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Nasledovanie_2
{
    class Abc
    {
        public int a;
        public Abc(int a)
            {
            this.a = a;
            }
        public void Show1()
        {
            Console.WriteLine("В базовом классе а={0}", a);
        }
    }

    class Def:Abc
    {
        //намеренное сокрытие переменной базового класса с тем же именем
        //оператор new  об этом как раз и говорит
        /*
        В производном классе можно определить член с таким же именем, как и у члена его базового класса. 
        В этом случае член базового класса скрывается в производном классе. И хотя формально в C# это не считается ошибкой, 
        компилятор все же выдаст сообщение, предупреждающее о том, что имя скрывается. Если член базового класса требуется 
        скрыть намеренно, то перед его именем следует указать ключевое слово new, чтобы избежать появления подобного 
        предупреждающего сообщения. Следует, однако, иметь в виду, что это совершенно отдельное применение ключевого слова new,
        не похожее на его применение при создании экземпляра объекта (в конструкторах производного класса)
        */
        new public int a;
        //base используется для передачи в конструктор базового класса параметра
        public Def(int b, int a):base(b)
        {
            //this  используется т.к. имя параметра совпадает с именем переменной класса
            this.a = a;

        }
        public void Show()
        {
            /*
             Несмотря на то что переменная экземпляра i в производном классе В скрывает
             переменную i из базового класса А, ключевое слово base разрешает доступ 
             к переменной i, определенной в базовом классе
             */
            //чтобы получить значение открытого члена a из базового класса
            //используем оператор base
            Console.WriteLine("a в базовом классе равно {0}", base.a);
            Console.WriteLine("a в производном классе равно {0}", a);
        }
        
        //аналогично с методами:
        new public void Show1()
        {
            //вызываем метод из базового класса
            base.Show1();
            //добавляем вывод переменной из производного класса
            Console.WriteLine("В производном классе а={0}", a);
        }
    }

    class Program
    {
        static void Main(string[] args)
        {
            Def val = new Def(4,5);
           
            val.Show();
            val.Show1();
            Console.ReadKey();
            
        }
    }
}
